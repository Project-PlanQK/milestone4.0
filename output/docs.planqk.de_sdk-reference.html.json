{
  "title": "Accessing Quantum Backends | PLANQK Docs",
  "content": "Accessing Quantum Backends | PLANQK Docs\nSkip to content\nSearch\nK\nMain Navigation\nLogin\nSign Up\nPricing\nQuantum Backends\nAppearance\nMenu\nReturn to top\nSidebar Navigation\nGetting Started\nQuickstart\nAvailable Backends\nQuantum SDK\nService SDK\nCLI Reference\nplanqk.json Reference\nManage Organizations\nManage Access Tokens\nManage Quantum Jobs\nImplementations\nIntroduction\nGetting Started\nImplementation Settings\nCreate a Service\nManaged Services\nIntroduction\nService Configuration\nDescribe your API\nRun as Jobs\nCustom Docker Containers\nRuntime Interface\nUsing a Service\nApplications\nUsing a Service\nService Orchestration\nIntroduction\nThe Workflow Editor\nA Workflow Example\nOn-Premise Services\nIntroduction\nPublish on Marketplace\nReport Service Usage\nDemos\nIntroduction\nDeploy a Demo\nSet Environment Variables\nStarter Templates\nAutomation\nCI/CD Integration with PLANQK\nGitHub Workflows\nGitLab CI\nTutorials\nExecute Qiskit Circuits using the PLANQK Quantum SDK\nSolving the Maximum Independent Set Problem on QuEra Aquila using the PLANQK Quantum SDK\nUtilize the PLANQK Service SDK for Local Development\nCreate and Test an On-Premise Service\nAccess D-Wave Leap in a PLANQK Service\nAccess IBM Quantum Platform Backends in a PLANQK Service\nUse Qiskit Runtime in a PLANQK Service\nCommunity\nIntroduction\nAlgorithms\nData Pools\nUse Cases\nMarkdown & LaTeX\nManage Permissions\nPublishing Content\nReviews\nOn this page\nAccessing Quantum Backends\n​\nThe PLANQK Quantum SDK provides an easy way to develop quantum code that runs on\nquantum hardware and simulators supported\nby the\nPLANQK Platform\n.\nThe SDK supports both the\nQiskit 1.3 SDK\nand the\nAmazon Braket SDK\n, allowing you to choose your preferred framework for quantum programming:\nQiskit: Access all gate-based quantum backends and simulators provided by PLANQK.\nAmazon Braket SDK: Access all devices provided by PLANQK through AWS, such as the QuEra Aquila quantum device.\nThis integration enables you to seamlessly adapt and reuse your existing Qiskit or Braket code within the PLANQK environment, maximizing productivity while working with the frameworks you are already accustomed to.\nIf you are using\nPennyLane\nto implement your quantum machine learning algorithms, you can use the\nSDK along with the PennyLane-Qiskit plugin\nto run them on the quantum hardware provided by PLANQK.\nInstallation\n​\nYou need to have Python 3.11 or higher installed. The package is released on PyPI and can be installed via\npip\n:\nbash\npip\ninstall\n--upgrade\nplanqk-quantum\nTIP\nEnsure that you have versions older than Qiskit SDK 1.3 uninstalled before installing the PLANQK Quantum SDK. The best practice is to create a new virtual environment and freshly install the SDK.\nAfter installing the SDK, you can start using it in conjunction with your preferred quantum framework:\nFollow the\nUsing Qiskit\nsection to begin creating quantum circuits and running them on supported devices through PLANQK.\nFollow test\nUsing Amazon Braket\nsection for building circuits or Analog Hamiltonian Simulations and running them on devices provided by PLANQK.\nAuthentication\n​\nTo use the SDK, you need to authenticate using an access token. You may use your personal access token found on the PLANQK\nwelcome page\n, or you can generate dedicated\naccess tokens\n.\nAn access token can be set in two ways:\nAutomatically, by logging in through the\nPLANQK CLI\n. The command to login via CLI is\nplanqk login -t <your_access_token>\n. This method will automatically inject the access token when you instantiate the\nPlanqkQuantumProvider\nor\nPlanqkBraketProvider\nclass. If you want to log in with your organization you need to additionally execute\nplanqk set-context\nand select the organization.\nExplicitly, during instantiation of the\nPlanqkQuantumProvider\nor\nPlanqkBraketProvider\nclass. This method overrides any access token that has been automatically injected through the PLANQK CLI login. You can optionally pass the organization id as a parameter, if you want to execute your circuit using your organization's account.\nIf the access token is not set, is invalid, or has expired, an\nInvalidAccessTokenError\nis thrown. You need to generate a new token and log-in again.\nUsing Qiskit\n​\nIn your Python code you can access the PLANQK quantum backends through the\nPlanqkQuantumProvider\nclass. Import the class and instantiate it as shown below:\npython\nfrom\nplanqk.qiskit\nimport\nPlanqkQuantumProvider\nIf you are already logged in with the\nPLANQK CLI\nyou can create the provider object without any parameters:\npython\nprovider\n=\nPlanqkQuantumProvider()\nAlternatively, you can also create the provider object by passing a personal access token as a parameter:\npython\nprovider\n=\nPlanqkQuantumProvider(\naccess_token\n=\n\"YOUR_PERSONAL_ACCESS_TOKEN_HERE\"\n)\nIf you want to log in with your organization, you can additionally pass the organization id as a parameter. The organization id can be found in the organization settings on the PLANQK Platform:\npython\nprovider\n=\nPlanqkQuantumProvider(\norganization_id\n=\n\"YOUR_ORGANIZATION_ID_HERE\"\n,\naccess_token\n=\n\"...\"\n)\nUse the Provider Class\n​\nAfter you have created the provider object, you can list all backends supported by PLANQK and select the one you want to use. The available backends and their ids can be also found\nhere\n:\npython\n# List all available PLANQK quantum backends\nbackends\n=\nprovider.backends()\n# Select a certain backend\nbackend\n=\nprovider.get_backend(\n\"azure.ionq.simulator\"\n)\nTIP\nTo access other QPUs, either you or your organization must have payment information added to your account. To upgrade your account, go to your\nAccount Settings\n, click the\nUpgrade\nbutton, and follow the prompts to enter your payment details.\nExecute a Quantum Circuit\n​\nNow you can execute your Qiskit circuit on the selected backend, retrieve its\njob\nobject, retrieve its results, or cancel it. The full example would look like this:\npython\nfrom\nplanqk.qiskit\nimport\nPlanqkQuantumProvider\nfrom\nqiskit\nimport\nQuantumCircuit, transpile\nprovider\n=\nPlanqkQuantumProvider()\nbackend\n=\nprovider.get_backend(\n\"azure.ionq.simulator\"\n)\n# Create a Qiskit circuit\ncircuit\n=\nQuantumCircuit(\n3\n,\n3\n)\ncircuit.h(\n0\n)\ncircuit.cx(\n0\n,\n1\n)\ncircuit.cx(\n1\n,\n2\n)\ncircuit.measure(\nrange\n(\n3\n),\nrange\n(\n3\n))\ncircuit\n=\ntranspile(circuit, backend)\njob\n=\nbackend.run(circuit,\nshots\n=\n100\n)\n# Monitor job status and get results\nprint\n(\nf\n\"Status:\n{\njob.status()\n}\n\"\n)\nprint\n(\nf\n\"Result:\n{\njob.result()\n}\n\"\n)\nIMPORTANT\nExecuting your quantum circuits or programs on PLANQK may lead to execution costs depending on selected backend and number of shots. Please find an overview about the costs for each backend\non our pricing page\n.\nRetrieving Quantum Jobs\n​\nDue to queuing at the quantum provider, job execution may take hours or even days. To retrieve your job later, you can use the\nretrieve_job\nfunction provided by the backend:\npython\nprovider\n=\nPlanqkQuantumProvider()\nbackend\n=\nprovider.get_backend(\n\"azure.ionq.simulator\"\n)\n# Retrieve the job through its id\njob\n=\nbackend.retrieve_job(\n\"6ac422ad-c854-4af4-b37a-efabb159d92e\"\n)\nYou can also get an overview of all your jobs by executing\nprovider.jobs()\nor by visiting the\nQuantum Jobs\npage.\nUsing Amazon Braket\n​\nIn your Python code you can access the PLANQK quantum backends through the\nPlanqkBraketProvider\nclass. We refer to these backends as\ndevices\nin the following to adhere to the Braket SDK naming conventions. Import the class and instantiate it as shown below:\npython\nfrom\nplanqk\nimport\nPlanqkBraketProvider\nIf you are already logged in with the\nPLANQK CLI\nyou can create the provider object without any parameters:\npython\nprovider\n=\nPlanqkBraketProvider()\nAlternatively, you can also create the provider object by passing your PLANQK\npersonal access token\n:\npython\nprovider\n=\nPlanqkBraketProvider(\naccess_token\n=\n\"YOUR_PERSONAL_ACCESS_TOKEN_HERE\"\n)\nIf you want to log in with your organization, you can additionally pass the organization id as a parameter. The organization id can be found in the organization settings on the PLANQK Platform:\npython\nprovider\n=\nPlanqkBraketProvider(\norganization_id\n=\n\"YOUR_ORGANIZATION_ID_HERE\"\n,\naccess_token\n=\n\"...\"\n)\nUse the Provider Class\n​\nAfter you have created the provider object, you can list all devices (backends) provided by the PLANQK Platform that can be accessed through Braket.\npython\n# List all available PLANQK quantum devices\ndevices\n=\nprovider.devices()\n# Select a certain device\ndevice\n=\nprovider.get_device(\n\"aws.ionq.forte\"\n)\nTIP\nTo access other QPUs, either you or your organization must have payment information added to your account. To upgrade your account, go to your\nAccount Settings\n, click the\nUpgrade\nbutton, and follow the prompts to enter your payment details.\nWorking with Braket Devices\n​\nNow you can execute your Braket circuit on the selected device, retrieve its\ntask\nobject, retrieve its results, cancel it etc. The full example would look like this:\npython\nfrom\nbraket.circuits\nimport\nCircuit\nfrom\nplanqk\nimport\nPlanqkBraketProvider\nfrom\nplanqk.braket.planqk_quantum_task\nimport\nPlanqkAwsQuantumTask\n# Select the IonQ Forte device\ndevice\n=\nPlanqkBraketProvider().get_device(\n\"aws.ionq.forte\"\n)\n# Create a Braket circuit\ncircuit\n=\nCircuit().h(\n0\n).cnot(\n0\n,\n1\n).cnot(\n1\n,\n2\n)\n# Execute the circuit with 100 shots\ntask\n=\ndevice.run(circuit,\n100\n)\n# Monitor task status and get results\nprint\n(\nf\n\"Status:\n{\ntask.state()\n}\n)\nprint(f\"\nResult: {task.result()})\nTo execute a task on the QuEra Aquila device, you'll need to create an\nAnalog Hamiltonian Simulation (AHS) program\nand discretize it according to the device specifications. This is described in detail using the Maximum Independent Set Problem in our\nQuera Aquila tutorial\n.\nRetrieving Braket Tasks\n​\nTo retrieve a task you ran earlier, note down its ID and create a PlanqkAwsQuantumTask object by providing the ID. Optionally, you can also provide an access token and an organization id.\npython\n# Submit the program to the device\ntask\n=\ndevice.run(circuit,\n100\n)\n# Get the task ID for future reference\nprint\n(\n\"Task ID:\"\n, task.id)\n# Example Output: Task ID: 6ac422ad-c854-4af4-b37a-efabb159d92e\n# Retrieve the task using its ID\ntask\n=\nPlanqkAwsQuantumTask(\n\"6ac422ad-c854-4af4-b37a-efabb159d92e\"\n)\nYou can also get an overview of your tasks by visiting the\nQuantum Jobs\npage. Note that your tasks are referred to as “jobs” on this page.\nSupported Operations\n​\nThis section provides an overview of the most important classes and methods in the SDK.\nPlanqkQuantumProvider\n​\nThe\nPlanqkQuantumProvider\nclass allows access to all gate-based backends via Qiskit.\nMethod\nDescription\nbackends()\nThis method returns a list of ids of backends supported by PLANQK. Please note that currently, backend filtering is not supported.\nget_backend(backend_id)\nThis method returns a single backend that matches the specified ID. If the backend cannot be found, a\nPlanqkClientError\nis thrown.\njobs()\nThis method retrieves a list of all jobs created by the user, sorted by their creation date with the newest jobs listed first.\nIf you specify\nazure.ionq.simulator\nas the backend ID, for example, by calling\nprovider.get_backend(\"azure.ionq.simulator\")\n, a\nPlanqkQiskitBackend\nis returned.\nQiskit Backends and Jobs\n​\nThe\nPlanqkQiskitBackend\nclass represents a\nQiskit Backend\n. It provides information about quantum backends (e.g., number of qubits, qubit connectivity, etc.) and enables you to run quantum circuits on the backend. Please note that currently, only circuits with gate-based operations are supported while pulse-based operations are not supported.\nThe\nPlanqkQiskitBackend\nclass supports the following methods:\nMethod\nDescription\nconfiguration()\nReturns the backend configuration data. This method is included for compatibility with older versions of Qiskit.\nrun(circuit, shots)\nExecutes a single circuit on the backend as a job (multiple circuits are currently not supported) and returns a\nPlanqkQiskitJob\n. You also need to specify the number of shots. The minimum and maximum number of supported shots differ for each backend and can be obtained from the backend properties\nmin_shots\nand\nmax_shots\n, respectively. A\nPlanqkClientError\nis thrown if the job input is invalid or if the designated backend is offline and does not accept new jobs in the moment.\nretrieve_job(job_id)\nRetrieves a job from the backend using the provided id. If a job cannot be found a\nPlanqkClientError\nis thrown.\nThis example shows how to run a circuit on a backend:\npython\n# Select a certain backend\nbackend\n=\nprovider.get_backend(\n\"azure.ionq.simulator\"\n)\n# Create a circuit\ncircuit\n=\nQuantumCircuit(\n2\n,\n2\n)\ncircuit.h(\n0\n)\ncircuit.cx(\n0\n,\n1\n)\ncircuit.measure(\nrange\n(\n2\n),\nrange\n(\n2\n))\n# Run the circuit on the backend\njob\n=\nbackend.run(circuit,\nshots\n=\n10\n)\n# Retrieve a job by id\njob\n=\nbackend.retrieve_job(\n\"6ac422ad-c854-4af4-b37a-efabb159d92e\"\n)\nQiskit Jobs & Results\n​\nThe class\nPlanqkQiskitJob\nrepresents a\nQiskit Job\n. It provides status information about a job (e.g., job id, status, etc.) and enables you to access the job result as soon as the job execution has completed successfully.\nMethods\n​\nMethod\nDescription\nstatus()\nReturns the status of the job. The\nQiskit job states\nare:\nINITIALIZING\n,\nQUEUED\n,\nRUNNING\n,\nCANCELLED\n,\nDONE\n,\nERROR\n.\nresult()\nReturns the result of the job. It blocks until the job execution has completed successfully. If the job execution has failed, a\nPlanqkClientError\nis thrown indicating that the job result is not available.\ncancel()\nCancels the job execution. If the job execution has already completed or if it has failed, this method has no effect.\nResults\n​\nThe type of result depends on the backend where the job was executed. Currently, only measurement result histograms are supported. The histogram is represented as a dictionary where the keys are the measured qubit states and the values are the number of occurrences. The measured qubit states are represented as bit-strings where the qubit farthest to the right is the most significant and has the highest index (little-endian). If supported by the backend, the result also contains the memory of the job execution, i.e., the qubit state of each individual shot.\nAttributes\n​\nAttribute\nDescription\ncounts\nReturns the histogram of the job result as a JSON dict.\nmemory\nReturns the memory as a JSON dict.\nHere is an example of how to access these attributes:\npython\nresult\n=\njob.result()\nprint\n(result.counts)\n# Expected output, e.g., {\"11\": 6, \"00\": 4}\nprint\n(result.memory)\n# Expected output, e.g., ['00', '11', '11', '00', '11', '00', '11', '11', '00', '11']\nPlanqkBraketProvider\n​\nThe\nPlanqkBraketProvider\nclass allows access to all backends provided through AWS. This is an overview of the available methods:\nMethod\nDescription\ndevices()\nThis method returns a list of ids of the devices supported by PLANQK through Braket.\nget_device(device_id)\nThis method returns a single device that matches the specified ID. If the backend cannot be found, a\nPlanqkClientError\nis thrown.\nIf you specify\naws.ionq.forte\nas the backend ID, for example, by calling\nprovider.get_device(\"aws.ionq.forte\")\n, a\nPlanqkAwsDevice\nis returned.\nBraket Devices and Tasks\n​\nThe\nPlanqkAwsDevice\nclass represents an\nAwsDevice\nand therefore provides the same properties and methods. Below are the key methods and properties:\nProperty / Method\nDescription\nstatus\nRetrieves the current status of the device.\nis_available\nReturns\ntrue\nif the device is online and ready to process tasks.\nproperties\nProvides the current properties of the device.\nrun(task_specification, shots)\nExecutes a Braket circuit or an Analog Hamiltonian Simulation program on PLANQK (batch executions are not currently supported) and returns a\nPlanqkAwsQuantumTask\n. You can specify the number of shots to perform; if not specified, 1000 shots are executed by default. A\nPlanqkClientError\nis thrown if the task input is invalid or if the device is offline and unable to accept new jobs.\nTasks & Results\n​\nThe\nPlanqkAwsQuantumTask\nclass is a representation of an\nAwsQuantumTask\n. This class provides essential status information about a task, such as its ID, current status, and allows access to its results once the execution is completed successfully.\nYou can obtain a\nPlanqkAwsQuantumTask\nobject directly from the\nrun\nfunction of the\nPlanqkAwsDevice\n. Alternatively, if you need to retrieve a task later, you can create a\nPlanqkAwsQuantumTask\nobject by specifying the task ID. For example, to retrieve a task with the ID\n123e4567-e89b-42d3-a456-556642440000\n, you would use:\npython\ntask\n=\nPlanqkAwsQuantumTask(\ntask_id\n=\n\"123e4567-e89b-42d3-a456-556642440000\"\n)\nIf you are not logged in through the PLANQK CLI, you must also provide your access token, and optionally, your organization ID.\npython\nPlanqkAwsQuantumTask(\ntask_id\n=\n\"123e4567-e89b...\"\n,\naccess_token\n=\n\"your_access_token\"\n,\norganization_id\n=\n\"your_organization_id\"\n)\nMethods\n​\nMethod\nDescription\nstatus()\nReturns the current status of the task, which could be\nQUEUED\n,\nRUNNING\n,\nCANCELLED\n,\nCOMPLETED\n, or\nFAILED\n.\nresult()\nReturns the execution result of the task. This method blocks until the task execution completes successfully. If the task fails, a\nPlanqkClientError\nis thrown, indicating that the result is unavailable.\ncancel()\nCancels the task execution. If the task has already completed or failed, this method has no effect.\nResults\n​\nIf you execute a Braket circuit the result object is of type\nGateModelQuantumTaskResult\n. For\nAnalogHamiltonianSimulationQuantumTaskResult\n. Both result classes include the shot measurements from the execution.\nA\nGateModelQuantumTaskResult\ncontains for instance the following properties:\npython\nresult\n=\ntask.result()\nprint\n(result.measurement_counts)\n# Expected output, e.g., Counter({'111': 2, '000': 1})\nprint\n(result.measurements)\n# Expected output [[0 0 0][1 1 1][1 1 1]]\nPennyLane Integration\n​\nTo use the SDK with PennyLane, you need to install the\nPennyLane-Qiskit plugin\nby adding the\npennylane-qiskit\npackage to your Python project dependencies, e.g., by running\npip install pennylane-qiskit==0.36\n.\nIMPORTANT\nCurrently, only\npennylane\nand\npennylane-qiskit\npackages version 0.36.0 are supported.\nTo execute a PennyLane circuit using a PLANQK backend, first, retrieve the desired backend using the\nPlanqkQuantumProvider\n.\nThen, create a\nqiskit.remote\ndevice and pass the PLANQK backend to it.\nThe following example shows how to create a remove device using the\nazure.ionq.simulator\nbackend:\npython\nprovider\n=\nPlanqkQuantumProvider()\nbackend\n=\nprovider.get_backend(\n\"azure.ionq.simulator\"\n)\ndevice\n=\nqml.device(\n'qiskit.remote'\n,\nwires\n=\n2\n,\nbackend\n=\nbackend,\nshots\n=\n100\n)\n@qml.qnode\n(device)\ndef\ncircuit\n():\nqml.Hadamard(\nwires\n=\n0\n)\nqml.CNOT(\nwires\n=\n[\n0\n,\n1\n])\nreturn\nqml.sample(qml.PauliZ(\n0\n)), qml.sample(qml.PauliZ(\n1\n))\nresult\n=\ncircuit()\nWhat's next?\n​\nSee our supported\nquantum backends and simulators\n.\nCheckout how to create your first\nPLANQK Service project\n.\nHelp us improve this page!\nLast updated:\nPager\nPrevious page\nAvailable Backends\nNext page\nService SDK\nPublished under the CC-BY-4.0 License.\nCopyright © 2023-present | Kipu Quantum GmbH",
  "url": "https://docs.planqk.de/sdk-reference.html"
}